<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Windows PowerShell进阶(21) IO操作之读取"><meta name="keywords" content="进阶,IO,Read"><meta name="author" content="超速蜗牛,undefined"><meta name="copyright" content="超速蜗牛"><title>Windows PowerShell进阶(21) IO操作之读取【超速蜗牛的博客】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"AOHMI93W80","apiKey":"3f74c7e8113768c69c3eedfd6540618f","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">超速蜗牛</div><div class="author-info-description">Learn PowerShell.</div><div class="links-buttons"><a class="links-button button-hover" href="https://gitee.com/chaoyuew" target="_blank">Gitee<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="mailto:348001390@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="tencent://message/?uin=348001390&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">26</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">34</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">2</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">超速蜗牛的博客</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Windows PowerShell进阶(21) IO操作之读取</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-08-25 | 更新于 2019-08-25</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/powershell/">powershell</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/进阶/">进阶</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/IO/">IO</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/Read/">Read</a></div></div></div><div class="main-content"><p>本文首发于本人公众号SPPS178,现搬运过来,较原文有所改动.</p>
<p>今天开始结合例子讲解,一般学习计算机语言第一件事都是读写文件,所以我们也从IO开始,进一步了解powershell.这一篇是我看到总结的比较好的，所以我就直接搬运了，想看英文原文的可以拖到文章底部查看原文。</p>
<p>任何系统管理员都知道日志文件是解决服务器问题的宝贵资产。有时，虽然这些文件可能非常大，并且难以处理，因为我碰巧在一周前的Powershell论坛讨论中注意到这一点。<br>要理解的是，在Powershell中使用的正确工具取决于您正在处理的文件类型。<br>以下是您读取文本文件的一系列选项：</p>
<a id="more"></a>

<ul>
<li>Get-Content</li>
<li>Get-Content -Raw</li>
<li>Get-Content -ReadCount</li>
<li>Switch -File</li>
<li>[System.IO.File]::ReadAllText()</li>
<li>[System.IO.File]::ReadAllLines()</li>
<li>[System.IO.File]::ReadLines()</li>
<li>[System.IO.File]::OpenText().readtoend()</li>
</ul>
<p><code>Get-Content</code>是您的开箱即用选项。 它适用于小日志文件，其使用非常简单，但对于大型日志文件来说，它可能非常慢。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Content</span> .\small.csv</span><br></pre></td></tr></table></figure>

<p>假设我们有四个不同大小和行数的日志文件：</p>
<ul>
<li>logfile0.log，一个小日志文件：4行和1KB大小</li>
<li>logfile1.log，一个中等大小的日志文件：70万行和160MB大小</li>
<li>logfile2.log，一个大尺寸的日志文件：30万行和1.2GB大小</li>
<li>logfile3.log，包含超过一百万行的日志文件：140万行和650MB大小</li>
</ul>
<p>我们来看看Get-Content可以针对这些文件做些什么：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile0.log&#125;).TotalSeconds</span><br><span class="line"><span class="number">0</span>,<span class="number">0013753</span></span><br><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile1.log&#125;).TotalSeconds</span><br><span class="line"><span class="number">12</span>,<span class="number">7561849</span></span><br><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile2.log&#125;).TotalSeconds</span><br><span class="line"><span class="number">11</span>,<span class="number">9634649</span></span><br><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile3.log&#125;).TotalSeconds</span><br><span class="line"><span class="number">229</span>,<span class="number">0962224</span></span><br></pre></td></tr></table></figure>

<p>对于那些较小的文件来说很快，但对于最后一个大文件来说太慢了，超过一百万条文件很难处理。<br>让我们看看上面列出的其他方法是如何执行的。 做一些性能测试不仅有趣，而且有助于更好地理解系统的工作方式。<br>正如我们刚才看到的，Get-Content的基本语法表现不佳.</p>
<p>自从Powershell v3以来，Get-Content有一个<code>-Raw</code>参数，它可以读取文本流中的文本文件，保持换行符不变。 正如你在下面看到的，它比Get-Content快得多，<strong>尽管如此，它对您的内存使用产生了巨大的影响</strong>(原文图片加载不出来，意思就是读取期间增加内存开销)</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile3.log -Raw&#125;).TotalSeconds</span><br><span class="line"><span class="number">46</span>,<span class="number">4201292</span></span><br></pre></td></tr></table></figure>

<p><strong>(编者:这里提一下, -raw参数虽然加快读取速度,但是其读出来的是一整个string对象,不带-raw参数时是array)</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\temp&gt; <span class="variable">$a</span>=cat .\test.ps1</span><br><span class="line">PS C:\temp&gt; <span class="variable">$b</span>=cat .\test.ps1 -raw</span><br><span class="line">PS C:\temp&gt; <span class="variable">$a</span> -is [array]</span><br><span class="line">True</span><br><span class="line">PS C:\temp&gt; <span class="variable">$b</span> -is [string]</span><br><span class="line">True</span><br><span class="line">PS C:\temp&gt;</span><br></pre></td></tr></table></figure>

<p>令人高兴的是，我们可以通过强制垃圾收集器在继续测试之前完成它的工作来处理内存中的数据：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC]::Collect()</span><br></pre></td></tr></table></figure>

<p>让我们继续讨论第三个选项：<code>-ReadCount</code>参数。 正如它在上述论坛讨论中所展示的那样，这个开关可以超出人们预期来加速Get-Content读取文本的速度，只要你为它找到合适的值（指-ReadCount后面跟的数字）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile3.log -ReadCount <span class="number">10</span>&#125;).TotalSeconds</span><br><span class="line"><span class="number">33</span>,<span class="number">9024254</span></span><br><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile3.log -ReadCount <span class="number">100</span>&#125;).TotalSeconds</span><br><span class="line"><span class="number">11</span>,<span class="number">1052492</span></span><br><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile3.log -ReadCount <span class="number">1000</span>&#125;).TotalSeconds</span><br><span class="line"><span class="number">7</span>,<span class="number">9866107</span></span><br><span class="line">(<span class="built_in">Measure-Command</span> &#123;<span class="built_in">Get-Content</span> .\logfile3.log -ReadCount <span class="number">10000</span>&#125;).TotalSeconds</span><br><span class="line"><span class="number">10</span>,<span class="number">4790464</span></span><br></pre></td></tr></table></figure>

<p>这个-ReadCount开关通过控制Get-Content一次写入管道的记录数来帮助加速进程。<br>根据我的经验，通过1000或10000行数据块读取文件通常会给出最佳结果，即使对于如此大的日志文件，对CPU和内存的影响也很小甚至没有影响。</p>
<p>-ReadCount的问题在于需要一些猜测才能找出特定文件的正确值(编者:这里指每次传给管道的行数值，上面的例子就是在找比较好的数值)，因为性能不仅随文件大小而变化，而且随每个记录的大小而变化。<br>你应该知道Get-Content的一个有趣的替代方法是使用Switch关键字：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Measure-Command</span> &#123;</span><br><span class="line">    <span class="keyword">Switch</span> -File .\logfile3.log &#123;</span><br><span class="line">        default &#123;<span class="variable">$PSItem</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).TotalSeconds</span><br><span class="line"><span class="number">10</span>,<span class="number">0711553</span></span><br></pre></td></tr></table></figure>

<p>不是很糟糕，不是吗？ 让我们来标记下一下，Switch对CPU使用量的影响略高于Get-Content -ReadCount(原文图片加载不出来，意思就是读取期间增加内存开销)</p>
<p>现在让我们看看使用<code>.NET</code>能否获得更好的结果。</p>
<p>第一个选项是ReadAllText()方法：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Measure-Command</span> &#123;[System.IO.File]::ReadAllText(<span class="string">'C:\temp\get-content\logfile3.log'</span>)&#125;).TotalSeconds</span><br><span class="line"><span class="number">13</span>,<span class="number">5002564</span></span><br></pre></td></tr></table></figure>

<p>ReadAllText()非常快，但对系统内存有暂时的影响。</p>
<p>第二个选项是ReadAllLines()：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Measure-Command</span> &#123;[System.IO.File]::ReadAllLines(<span class="string">'C:\temp\get-content\logfile3.log'</span>)&#125;).TotalSeconds</span><br><span class="line"><span class="number">16</span>,<span class="number">3589887</span></span><br></pre></td></tr></table></figure>

<p>不如ReadAllText()，但它对内存分配的影响略小一些：<br>第三个选项是ReadLine()，它不同于ReadAllLines()，因为它允许您在返回整个集合之前开始枚举字符串集合（令人印象深刻的结果。）</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Measure-Command</span> &#123;[System.IO.File]::ReadLines(<span class="string">'C:\temp\get-content\logfile3.log'</span>)&#125;).TotalSeconds</span><br><span class="line"><span class="number">6</span>,<span class="number">5551735</span></span><br></pre></td></tr></table></figure>

<hr>
<p>编者语：</p>
<p>这个在微软官网<a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.file.readlines?view=netframework-4.8" target="_blank" rel="noopener">File.ReadLines Method</a><code>Remarks</code>有如下差异介绍:</p>
<blockquote>
<p>The <code>ReadLines</code> and <code>ReadAllLines</code> methods differ as follows: When you use ReadLines, you can start enumerating the collection of strings before the whole collection is returned; when you use ReadAllLines, you must wait for the whole array of strings be returned before you can access the array. Therefore, when you are working with very large files, ReadLines can be more efficient.</p>
</blockquote>
<p>这里个人理解有点类似管道，只要开始读，那么读一行，我们就可以对读过的的这一行做操作，不用等到全部读完。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Foreach</span>( <span class="variable">$line</span> <span class="keyword">in</span> [IO.File]::ReadLines(<span class="string">"D:\temp\test.log"</span>))&#123;</span><br><span class="line">    <span class="built_in">write-host</span> <span class="variable">$line</span></span><br><span class="line">&#125;</span><br><span class="line">cat <span class="string">"D:\temp\test.log"</span>|%&#123;<span class="built_in">write-host</span> <span class="variable">$_</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>让我们看下第四个也是最后一个选项是OpenText().readtoend()：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Measure-Command</span> &#123;[System.IO.File]::OpenText(<span class="string">'C:\temp\get-content\logfile3.log'</span>).readtoend()&#125;).TotalSeconds</span><br><span class="line"><span class="number">10</span>,<span class="number">8803161</span></span><br></pre></td></tr></table></figure>

<p>很好的表现,但是，与其他两种.NET方法相同，需要分配大量内存，因为它们将整个文件读入内存，并且代码在某些情况下可能会抛出System.OutOfMemoryException类型的异常。</p>
<p>另外，你已经注意到了，在使用.NET时，<code>文件路径必须完全指定(即全路径)</code>，否则Powershell将无法找到它。<br>总之，使用Get-Content -ReadCount查找文件似乎是读取大文本文件的第二快方法。 大文件的第一个选项是[System.IO.File]::ReadLines()：</p>
<ul>
<li>[System.IO.File]::ReadLines(): 6 seconds</li>
<li>Get-Content -ReadCount 1000: 7 seconds</li>
<li>Switch -File: 10 seconds</li>
<li>[System.IO.File]::OpenText().readtoend(): 10 seconds</li>
<li>[System.IO.File]::ReadAllText(): 13 seconds</li>
<li>[System.IO.File]::ReadAllLines(): 16 seconds</li>
<li>Get-Content -Raw: 46 seconds</li>
<li>Get-Content: 229 seconds</li>
</ul>
<p>编者:需要注意的一点是.NET的方法读取文件时,要确保没有别的程序在打开这个文件或者正在往里面写内容.否则会报下面的错误，所以个人建议对于大文件，不确定文件是否会被占用的情况下，优先使用Get-Content -ReadCount 1000，我试了下1000应该还算是较优解，在公司机子上找了一个2.6G的log file，试了下大概24s，而Get-Content需要7-8分钟，相差17倍左右。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\a001052&gt; [io.file]::ReadAllLines(<span class="string">"C:\temp\WinVNC.log"</span>)</span><br><span class="line">Exception calling <span class="string">"ReadAllLines"</span> with <span class="string">"1"</span> argument(s): <span class="string">"The process cannot access the file 'C:\temp\WinVNC.log'</span></span><br><span class="line"><span class="string">because it is being used by another process."</span></span><br><span class="line">At line:<span class="number">1</span> char:<span class="number">1</span></span><br><span class="line">+ [io.file]::ReadAllLines(<span class="string">"C:\temp\WinVNC.log"</span>)</span><br><span class="line">+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : NotSpecified: (:) [], MethodInvocationException</span><br><span class="line">    + FullyQualifiedErrorId : IOException</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考链接<br><a href="http://www.happysysadm.com/2014/10/reading-large-text-files-with-powershell.html" target="_blank" rel="noopener">Reading large text files with Powershell</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">超速蜗牛</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://chaoyuew.gitee.io/WPS-21-Advanced-IO-Read.html">https://chaoyuew.gitee.io/WPS-21-Advanced-IO-Read.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chaoyuew.gitee.io">超速蜗牛的博客</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/WPS-22-Advanced-IO-Write.html"><i class="fas fa-angle-left">&nbsp;</i><span>Windows PowerShell进阶(22) IO操作之写入</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/WPS-20-Basic-Summarize.html"><span>Windows PowerShell入门（20）总结</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2019 By 超速蜗牛</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>