<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Windows PowerShell进阶(29) Windows API 交互"><meta name="keywords" content="进阶,API"><meta name="author" content="超速蜗牛,undefined"><meta name="copyright" content="超速蜗牛"><title>Windows PowerShell进阶(29) Windows API 交互【超速蜗牛的博客】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"AOHMI93W80","apiKey":"3f74c7e8113768c69c3eedfd6540618f","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-PowerShell-to-Interact-with-the-Windows-API-Part1"><span class="toc-number">1.</span> <span class="toc-text">Use PowerShell to Interact with the Windows API Part1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Add-Type的背景"><span class="toc-number">1.1.</span> <span class="toc-text">使用Add-Type的背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Add-Type来调用CopyItem函数"><span class="toc-number">1.2.</span> <span class="toc-text">使用Add-Type来调用CopyItem函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-PowerShell-to-Interact-with-the-Windows-API-Part2"><span class="toc-number">2.</span> <span class="toc-text">Use PowerShell to Interact with the Windows API Part2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-PowerShell-to-Interact-with-the-Windows-API-Part3"><span class="toc-number">3.</span> <span class="toc-text">Use PowerShell to Interact with the Windows API Part3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义动态方法的步骤"><span class="toc-number">3.1.</span> <span class="toc-text">定义动态方法的步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">超速蜗牛</div><div class="author-info-description">Learn PowerShell.</div><div class="links-buttons"><a class="links-button button-hover" href="https://gitee.com/chaoyuew" target="_blank">Gitee<i class="icon-dot bg-color6"></i></a><a class="links-button button-hover" href="mailto:348001390@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="tencent://message/?uin=348001390&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">35</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">44</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">2</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">超速蜗牛的博客</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Windows PowerShell进阶(29) Windows API 交互</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-09-03 | 更新于 2019-09-03</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/powershell/">powershell</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/进阶/">进阶</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/API/">API</a></div></div></div><div class="main-content"><p>本文首发于本人公众号SPPS178,现搬运过来,较原文有所改动.</p>
<p>本来打算接着讲excel相关操作的，这2天看了下DLL import的文章，所以这篇先讲下powershell 导入DLL file的相关知识点,需要一点C/C++和c#基础。我们上一篇要增加module和保存CSV的时候都导入了额外的DLL文件，是因为我们要用到里面的属性/方法等。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[void][System.Reflection.Assembly]::Load([io.file]::ReadAllBytes(<span class="string">"<span class="variable">$PSScriptRoot</span>\Microsoft.Vbe.Interop.dll"</span>))</span><br><span class="line"><span class="variable">$xlmodule</span> =<span class="variable">$workbook</span>.VBProject.VBComponents.Add([Microsoft.Vbe.Interop.vbext_ComponentType]::vbext_ct_StdModule)</span><br><span class="line">[void][System.Reflection.Assembly]::Load([io.file]::ReadAllBytes(<span class="string">"<span class="variable">$PSScriptRoot</span>\microsoft.office.interop.excel.dll"</span>))</span><br><span class="line"><span class="variable">$workbook</span>.saveas(<span class="variable">$result_file</span>,[Microsoft.Office.Interop.Excel.XlFileFormat]::xlCSV)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>我们通过反编译软件ILSpy（开源软件，后文有链接）可以在对应的DLL内部找到这2个枚举变量。</p>
<center><img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://ww1.sinaimg.cn/large/007tGxtGgy1g6mp4j2a9zj30iv0jhtb0.jpg"><br>29-1 Excell-DLL-Variable<div></div></center>

<p>这篇内容主要基于微软官方的<code>Use PowerShell to Interact with the Windows API</code>3个系列，后文会有链接，可直接阅读英文原文，以下为原文翻译（大部分机翻，话说现在谷歌翻译基本能做到我想要的结果了，代码部分它还知道不用翻译）</p>
<h3 id="Use-PowerShell-to-Interact-with-the-Windows-API-Part1"><a href="#Use-PowerShell-to-Interact-with-the-Windows-API-Part1" class="headerlink" title="Use PowerShell to Interact with the Windows API Part1"></a>Use PowerShell to Interact with the Windows API Part1</h3><blockquote>
<p><a href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/25/use-powershell-to-interact-with-the-windows-api-part-1/" target="_blank" rel="noopener">https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/25/use-powershell-to-interact-with-the-windows-api-part-1/</a></p>
</blockquote>
<p>我经常发现自己需要使用Windows PowerShell与Windows API函数进行交互来完成低级任务。 对于那些不熟悉Windows API的人来说，基本上，它指的是内置系统DLL公开的功能。 例如，kernel32.dll公开了数百种可供开发人员用于与操作系统交互的功能。</p>
<p>在Windows PowerShell中，有三种与Windows API函数交互的方式：</p>
<ul>
<li>使用Add-Type cmdlets编译C＃代码。 这是官方说明的方法。</li>
<li>获取对调用方法的.NET Framework中的私有类型的引用。</li>
<li>使用反射来动态定义调用Windows API函数的方法。</li>
</ul>
<h4 id="使用Add-Type的背景"><a href="#使用Add-Type的背景" class="headerlink" title="使用Add-Type的背景"></a>使用Add-Type的背景</h4><p>在下面的示例中，我将kernel32.dll中的<code>CopyFile</code>函数用作Windows PowerShell将与之交互的函数。 现在，您现在可能心中会有疑问：“为什么我想在Windows PowerShell已经有<code>Copy-Item</code> cmdlets时调用<code>CopyFile</code>？”</p>
<p>确实，这是一个非常好的问题。 事实证明，Windows PowerShell文件管理程序不知道如何处理某些文件路径。 特别是，它不知道如何解释特殊设备对象路径，例如：<code>\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\System32\calc.exe</code>。 这些是与卷影复制服务备份的文件进行交互时需要处理的各种路径。 例如，运行以下命令可列出每个卷影副本的设备对象路径：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> Win32_ShadowCopy | <span class="built_in">Select-Object</span> DeviceObject <span class="comment"># Run this from an administrative prompt</span></span><br><span class="line"></span><br><span class="line">DeviceObject                                   </span><br><span class="line">------------                                   </span><br><span class="line">\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1</span><br></pre></td></tr></table></figure>

<p>在深入使用Windows PowerShell调用<code>CopyFile</code>之前，先了解C/C++类型与.NET类型的背景有所帮助。 根据MSDN文档<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363851(v=vs.85).aspx" target="_blank" rel="noopener">CopyFile function</a>，CopyFile具有以下函数定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CopyFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPCTSTR lpExistingFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPCTSTR lpNewFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ BOOL    bFailIfExists</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所以CopyFile有一个返回类型BOOL和三个参数 - 两个<code>T</code>字符串和一个布尔值。 与Win API函数交互的关键是知道如何将这些C / C ++类型转换为等效的.NET类型。 幸运的是，有一个网站致力于这个任务：<a href="https://www.pinvoke.net/" target="_blank" rel="noopener">PINVOKE.NET</a>，它提供了执行此任务所需的信息类型的宝库。 这是值得您放入收藏夹中的书签。</p>
<p>如果您在PINVOKE.NET上搜索CopyFile，则会发现以下C#定义( 编者：大家可直接访问这个页面<a href="https://www.pinvoke.net/default.aspx/kernel32/CopyFile(2017-02-25-11-12-53.3736--203.158.51.233).html" target="_blank" rel="noopener">https://www.pinvoke.net/default.aspx/kernel32/CopyFile(2017-02-25-11-12-53.3736--203.158.51.233).html</a> )：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Unicode)]</span><br><span class="line">static extern bool CopyFile(string lpExistingFileName, string lpNewFileName, bool bFailIfExists);</span><br></pre></td></tr></table></figure>

<p>您现在可以看到C / C ++类型到.NET类型的转换：</p>
<ul>
<li>BOOL -&gt; bool</li>
<li>LPCTSTR -&gt; string</li>
</ul>
<p>现在，您应该拥有开始使用Windows PowerShell与CopyFile函数交互所需的背景。 我们来看看我们的第一种交互方式<code>Add-Type</code>。</p>
<h4 id="使用Add-Type来调用CopyItem函数"><a href="#使用Add-Type来调用CopyItem函数" class="headerlink" title="使用Add-Type来调用CopyItem函数"></a>使用Add-Type来调用CopyItem函数</h4><p><code>Add-Type</code> cmdlets用于定义将用于Windows PowerShell会话的.NET类型。 真正很酷的是它可以实时编译C＃代码。 如果您查看<code>Add-Type</code>的帮助，您会发现一些很好的如何调用Windows API函数的示例。</p>
<p>作为示例，下面的代码允许我在Windows PowerShell中调用CopyItem函数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$MethodDefinition</span> = <span class="string">@'</span></span><br><span class="line"><span class="string">[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]</span></span><br><span class="line"><span class="string">public static extern bool CopyFile(string lpExistingFileName, string lpNewFileName, bool bFailIfExists);</span></span><br><span class="line"><span class="string">'@</span></span><br><span class="line"><span class="variable">$Kernel32</span> = <span class="built_in">Add-Type</span> -MemberDefinition <span class="variable">$MethodDefinition</span> -Name <span class="string">'Kernel32'</span> -Namespace <span class="string">'Win32'</span> -PassThru</span><br><span class="line"><span class="comment"># You may now call the CopyFile function</span></span><br><span class="line"><span class="comment"># Copy calc.exe to the user's desktop</span></span><br><span class="line"><span class="variable">$Kernel32::CopyFile</span>(<span class="string">"$(<span class="variable">$Env:SystemRoot</span>)\System32\calc.exe"</span>, <span class="string">"$(<span class="variable">$Env:USERPROFILE</span>)\Desktop\calc.exe"</span>, <span class="literal">$False</span>)</span><br></pre></td></tr></table></figure>

<p><code>$MethodDefinition</code>变量只包含了我从PINVOKE.NET取得的C#定义，并进行了一些小修改：我将CopyFile方法定义为public。 使用Add-Type添加的方法必须是public才能在Windows PowerShell中轻松与它们交互。</p>
<p>然后我调用Add-Type并提供C#源代码，类型名称和名称空间。 通过指定类型名称和名称空间，在调用Add-Type后，可以使用<code>[Win32.Kernel32]</code>在WindowsPowerShell中引用新类型。(默认情况下，Add-Type不会输出它创建的类型定义。 -PassThru参数告诉它输出类型定义。)</p>
<p>在调用Add-Type之后，您可以最终在Windows PowerShell中直接调用CopyFile。 前面的示例只是将calc.exe复制到用户的桌面。 值得注意的是，紧跟<code>$Kernel32</code>变量后面的两个冒号，这表明你正在调用一个静态的.NET方法。 所有静态方法在Windows PowerShell中都以此方式调用。</p>
<p>将以上步骤打包，我写了Copy-RawItem函数，很好地包装了CopyFile函数。 完整脚本在微软脚本中心仓库：<a href="https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Add-Type-39741f8c" target="_blank" rel="noopener">Copy-RawItem（Add-Type Version）</a>（请大家自行下载，这里就不写脚本原文了，占篇幅）</p>
<p>下图显示了使用Copy-RawItem函数。</p>
<center><img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://ww1.sinaimg.cn/large/007tGxtGgy1g6mp6wob68j30it0c3q3b.jpg"><br>29-2 Copy-RawItem(Add-Type Version)<div></div></center>

<p>Copy-RawItem中唯一值得解释的代码是发生错误检查的最后几行。 MSDN文档指出，如果CopyFile返回FALSE，则会发生错误。 在C/C ++中，您可以通过调用GetLastError来确定错误的原因。 在Windows PowerShell中，可以通过抛出<a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.win32exception?view=netframework-4.8" target="_blank" rel="noopener">ComponentModel.Win32Exception</a>对象来引发错误。 这就是允许您在不调用GetLastError的情况下从Win API函数中剔除错误的方法。</p>
<h3 id="Use-PowerShell-to-Interact-with-the-Windows-API-Part2"><a href="#Use-PowerShell-to-Interact-with-the-Windows-API-Part2" class="headerlink" title="Use PowerShell to Interact with the Windows API Part2"></a>Use PowerShell to Interact with the Windows API Part2</h3><blockquote>
<p><a href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/26/use-powershell-to-interact-with-the-windows-api-part-2/" target="_blank" rel="noopener">https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/26/use-powershell-to-interact-with-the-windows-api-part-2/</a></p>
</blockquote>
<p>在我上一篇文章中，我介绍了如何使用Add-Type cmdlets与Windows API交互; 特别是kernel32.dll中的CopyFile函数。 今天，我将介绍另一种可以与Windows API函数交互的方法：从.NET Framework中提取私有方法。</p>
<p>对于大多数人来说，Add-Type方法总是足够的。 然而，对于像我这样编写安全和取证工具的人来说，取证足迹保持在最小范围内时有必要的，但是Add-Type却做不到这一点，因为它会将临时文件写入磁盘并调用csc.exe来编译C#代码。 因此，如果您的脚本需要最小的取证脚印（或者如果您喜欢以困难的方式执行操作），还有其他调用Windows API函数的方法。</p>
<p>.NET Framework的很大一部分实际上是在Windows API上构建的。 它只是没有公开暴露给你。 提取.NET Framework使用的Win API函数需要对.NET的内部布局有一个基本的了解。</p>
<p>有几种可用于探索.NET Framework的工具，包括（编者：推荐ILSpy免费，第一个貌似收费）：</p>
<ul>
<li><p><a href="https://www.red-gate.com/products/dotnet-development/reflector/" target="_blank" rel="noopener">.NET Reflector 8</a></p>
</li>
<li><p><a href="https://github.com/icsharpcode/ILSpy" target="_blank" rel="noopener">ILSpy .NET Decompiler</a></p>
</li>
</ul>
<p>对于我们的目的，您需要知道的一点是，.NET中的Windows API函数调用通常是非公共的（即私有的private）静态方法，它们具有与它们关联的DllImport属性（编者：就是上文我们看到的）。 为了帮助我们深入研究.NET Framework，我编写了一个名为Find-WinAPIFunction的帮助函数。 (该脚本也可在脚本中心存储库中找到，请自行下载：<a href="http://gallery.technet.microsoft.com/scriptcenter/Find-WinAPIFunction-4166b223" target="_blank" rel="noopener">http://gallery.technet.microsoft.com/scriptcenter/Find-WinAPIFunction-4166b223</a> )它在Windows PowerShell会话中搜索加载的模块，以查看专用Windows API函数。</p>
<p><fond color="yellow"><strong>下面是重点内容</strong></fond></p>
<p>Find-WinAPIFunction函数通过深入探索Windows PowerShell会话中的所有加载的程序集来实现它的功能。 要了解发生了什么，请将您的Windows PowerShell会话视为一系列容器。 它从一个AppDomain开始。 每个Windows PowerShell会话都有一个默认的AppDomain，您可以将其视为一个执行沙箱。</p>
<p>在一个AppDomain中，有多个加载的程序集assemblies。 程序集是模块module的容器，它通常是一个DLL，如mscorlib.dll或System.dll。 在组件中，是模块，它们是类型type的容器（也就是类class）。</p>
<p>最后，类型是成员的容器。 成员由方法，属性，字段，事件，嵌套类型和构造函数组成。 熟悉Get-Member cmdlets的成员的概念应该很熟悉。 下图可以更清楚地说明这种划分概念。</p>
<center><img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://ww1.sinaimg.cn/large/007tGxtGgy1g6mp7nqf51j30gm0cf0t9.jpg"><br><div>29-3 Powershell 组件层次图</div></center>

<p><code>Find-WinAPIFunction</code>首先遍历当前AppDomain中的所有程序集。 然后遍历这些程序集中的所有类型，最终寻找您正在搜索的方法。</p>
<center><img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://ww1.sinaimg.cn/large/007tGxtGgy1g6mp8hgttvj30it0ib3zr.jpg"><br>29-4 Find-WinAPIFunction-Works<div></div></center>

<p>现在我们知道CopyFile方法存在，我们知道我们可以在Windows PowerShell中使用它。 但是，不要每次使用Find-WinAPIFunction搜索它，让我们拿出一些信息，以便我们快速获得对我们的目标CopyFile方法的引用：</p>
<center><img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://ww1.sinaimg.cn/large/007tGxtGgy1g6mp8vm20cj30r609p0y6.jpg"><br>29-5 CopyFile-C#-DLL<div></div></center>


<p>从这个截图中可以看出，我们需要包含CopyFile方法的程序集和类型的名称。 这些分别是mscorlib.dll和Microsoft.Win32.Win32Native。现在让我们把所有的一切都与Copy-RawItem函数的另一个实现结合在一起，该函数在本系列的第1部分中首次亮相。 这一次，我们有私有.NET方法版本，该版本也可以在Script Center Repository中找到，请自行下载。（<a href="https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Private-NET-78917643" target="_blank" rel="noopener">https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Private-NET-78917643</a> ）。</p>
<p><u>编者：可能有些小伙伴疑惑了，CopyFile不是在kernel32.dll里面的吗，怎么现在又变成了mscorlib.dll，这里其实涉及到托管代码和非托管代码了，有兴趣的可以自己先了解下。我的理解是c#写了mscorlib.dll这个文件，然后在里面引用了C/C++写的kernel32.dll，然后kernel32.dll里面含有CopyFile方法。</u></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># part code of the script</span></span><br><span class="line"><span class="comment"># Get a reference to the internal method - Microsoft.Win32.Win32Native.CopyFile()</span></span><br><span class="line"><span class="variable">$mscorlib</span> = [AppDomain]::CurrentDomain.GetAssemblies() | ? &#123;<span class="variable">$_</span>.Location -and (<span class="variable">$_</span>.Location.Split(<span class="string">'\'</span>)[-<span class="number">1</span>] <span class="nomarkup">-eq</span> <span class="string">'mscorlib.dll'</span>)&#125;</span><br><span class="line"><span class="variable">$Win32Native</span> = <span class="variable">$mscorlib</span>.GetType(<span class="string">'Microsoft.Win32.Win32Native'</span>)</span><br><span class="line"><span class="variable">$CopyFileMethod</span> = <span class="variable">$Win32Native</span>.GetMethod(<span class="string">'CopyFile'</span>, ([Reflection.BindingFlags] <span class="string">'NonPublic, Static'</span>))</span><br><span class="line"><span class="comment"># Perform the copy</span></span><br><span class="line"><span class="variable">$CopyResult</span> = <span class="variable">$CopyFileMethod</span>.Invoke(<span class="literal">$null</span>, @(<span class="variable">$Path</span>, <span class="variable">$Destination</span>, ([Bool] <span class="variable">$PSBoundParameters</span>[<span class="string">'FailIfExists'</span>])))</span><br><span class="line"><span class="variable">$HResult</span> = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()</span><br></pre></td></tr></table></figure>

<p>此版本的<code>Copy-RawItem</code>提供了与<code>Add-Type</code>版本相同的功能，但它实现了本文中描述的私有方法提取技术。 该函数首先获取对mscorlib.dll的引用，mscorlib.dll是包含<code>CopyFile</code>方法的程序集。 然后通过调用<code>GetType</code>方法获取包含Microsoft.Win32.Win32Native方法的类型的引用。 最后，它通过调用<code>GetMethod</code>方法获得对<code>CopyFile</code>方法的引用，指定请求<code>NonPublic</code>，<code>Static</code>方法。</p>
<p>所描述的技术需要更多关于.NET Framework布局的知识。 但是，凭借这些知识，您将能够将内部功能引入Windows PowerShell，否则这些功能无法提供给您。在本系列的最后一篇也是最后一篇文章中，我们将深入挖掘.NET内幕，并且了解如何使用反射来动态构建调用Windows API函数的方法。</p>
<p>编者： 这时候我们发现上篇导入DLL静态属性的用法</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[void][System.Reflection.Assembly]::Load([io.file]::ReadAllBytes(<span class="string">"<span class="variable">$PSScriptRoot</span>\Microsoft.Vbe.Interop.dll"</span>))</span><br><span class="line"><span class="variable">$xlmodule</span> =<span class="variable">$workbook</span>.VBProject.VBComponents.Add([Microsoft.Vbe.Interop.vbext_ComponentType]::vbext_ct_StdModule)</span><br></pre></td></tr></table></figure>

<p>也可以用下面方式来写</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$vbe_module</span>=[System.Reflection.Assembly]::Load([io.file]::ReadAllBytes(<span class="string">"C:\Users\SPPS\SPPS28\Microsoft.Vbe.Interop.dll"</span>))</span><br><span class="line"><span class="variable">$vbe_class</span> = <span class="variable">$vbe_module</span>.GetType(<span class="string">'Microsoft.Vbe.Interop.vbext_ComponentType'</span>) </span><br><span class="line"><span class="variable">$xlmodule</span> =<span class="variable">$workbook</span>.VBProject.VBComponents.Add(<span class="variable">$vbe_class::vbext_ct_StdModule</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Use-PowerShell-to-Interact-with-the-Windows-API-Part3"><a href="#Use-PowerShell-to-Interact-with-the-Windows-API-Part3" class="headerlink" title="Use PowerShell to Interact with the Windows API Part3"></a>Use PowerShell to Interact with the Windows API Part3</h3><blockquote>
<p><a href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/27/use-powershell-to-interact-with-the-windows-api-part-3/" target="_blank" rel="noopener">https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/27/use-powershell-to-interact-with-the-windows-api-part-3/</a></p>
</blockquote>
<p>在上两篇文章中，我介绍了两种与Windows API交互的方法。 在这篇文章中，我将介绍最后一个和最后一个方法：反射。</p>
<p>反射使程序员能够对代码执行类型自省。 您在Windows PowerShell中执行的最常见的类型自检形式将使用<code>Get-Member</code> cmdlets，该cmdlets使您可以发现对象的方法和属性。 在最后一篇文章中，我们还使用了反射来查找实现kernel32.dll <code>CopyFile</code>函数的非公共方法。 在这篇文章中，我们将使用反射来动态生成代码。 这个概念被称为元编程。</p>
<h4 id="定义动态方法的步骤"><a href="#定义动态方法的步骤" class="headerlink" title="定义动态方法的步骤"></a>定义动态方法的步骤</h4><p>要定义一个将调用kernel32.dll中的CopyFile方法的动态方法，需要执行以下步骤：</p>
<ol>
<li><p>定义一个动态组件。回想一下，组件集是模块，类型和成员的容器。</p>
</li>
<li><p>在当前的AppDomain中定义动态组件集。将AppDomain视为Windows PowerShell会话。这是我们的方法将要执行的环境。</p>
</li>
<li><p>定义一个动态模块。模块是类型及其成员的容器。</p>
</li>
<li><p>定义一个动态类型。类型（即类）是成员（方法，属性，嵌套类型，字段，事件和构造函数）的容器。</p>
</li>
<li><p>定义我们的动态方法。这里我们指定属性（Public和Static）以及方法的参数和返回类型。</p>
</li>
<li><p>手动构建一个<code>DllImport</code>属性。结果将等同于以下C#属性：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[DllImport（“kernel32.dll”，SetLastError = true，PreserveSig = true，CallingConvention = CallingConvention.WinApi，CharSet = CharSet.Unicode）]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将自定义<code>DllImport</code>属性应用于动态方法。</p>
</li>
<li><p>调用<code>CreateType</code>方法将所有内容一起烘焙，并使我们的方法可用于我们的Windows PowerShell会话。</p>
</li>
</ol>
<p>正如你所看到的，这不是一个微不足道的过程。 此过程涉及执行的任务通常<code>Add-Type</code>和C#编译器会帮您处理的。所以你现在可能会问，“为什么我会想要通过所有这些麻烦来调用一个函数？”我通常这样做的原因是双重的：</p>
<ol>
<li>我需要在执行我的脚本时保持最小的取证脚印。 我不想调用C＃编译器并将临时文件写入磁盘。</li>
<li>我想要的Windows API函数不存在于由我当前的Windows PowerShell会话加载的.NET Framework部分中。</li>
</ol>
<p>为了看到所有这些，我写了另一个使用反射的Copy-RawItem函数的实现。 该功能的完整文本在Script Center Repository中可用：<a href="https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Reflection-38fae6d4" target="_blank" rel="noopener">Copy-RawItem（Reflection Version）</a></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># part code of the script</span></span><br><span class="line"><span class="comment"># Create a new dynamic assembly. An assembly (typically a dll file) is the container for modules</span></span><br><span class="line"><span class="variable">$DynAssembly</span> = <span class="built_in">New-Object</span> System.Reflection.AssemblyName(<span class="string">'Win32Lib'</span>)</span><br><span class="line"><span class="comment"># Define the assembly and tell is to remain in memory only (via [Reflection.Emit.AssemblyBuilderAccess]::Run)</span></span><br><span class="line"><span class="variable">$AssemblyBuilder</span> = [AppDomain]::CurrentDomain.DefineDynamicAssembly(<span class="variable">$DynAssembly</span>, [Reflection.Emit.AssemblyBuilderAccess]::Run)</span><br><span class="line"><span class="comment"># Define a new dynamic module. A module is the container for types (a.k.a. classes)</span></span><br><span class="line"><span class="variable">$ModuleBuilder</span> = <span class="variable">$AssemblyBuilder</span>.DefineDynamicModule(<span class="string">'Win32Lib'</span>, <span class="literal">$False</span>)</span><br><span class="line"><span class="comment"># Define a new type (class). This class will contain our method - CopyFile</span></span><br><span class="line"><span class="comment"># I'm naming it 'Kernel32' so that you will be able to call CopyFile like this:</span></span><br><span class="line"><span class="comment"># [Kernel32]::CopyFile(src, dst, FailIfExists)</span></span><br><span class="line"><span class="variable">$TypeBuilder</span> = <span class="variable">$ModuleBuilder</span>.DefineType(<span class="string">'Kernel32'</span>, <span class="string">'Public, Class'</span>)</span><br></pre></td></tr></table></figure>

<center><img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://ww1.sinaimg.cn/large/007tGxtGgy1g6mp9izzyqj30pp0jygmv.jpg"><br><div>29-6 Copy-RawItem(Reflection Version)</div></center>

<p>这包括了我关于使用Windows PowerShell与Windows API进行交互的系列文章。 正如你所看到的，这个过程可以像你想要的那样简单或复杂。 您选择哪种方法最终将取决于您的独特执行要求。 但是在大多数情况下，使用Add-Type编译C#代码就足够了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一篇作为知识延伸拓宽，能够了解powershell在.NET框架上是怎么与底层交互的。其实我在写这篇文章之前，对这些知识点都还是很模糊的状态，自己试着翻译过来之后，再结合官方的说明文档，有些问题已经能够想明白了。希望你也能因此有所收获。下次见(^▽^)</p>
<blockquote>
<p>参考链接<br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363851(v=vs.85).aspx" target="_blank" rel="noopener">CopyFile函数 </a><br><a href="https://www.pinvoke.net/" target="_blank" rel="noopener">PINVOKE.NET</a><br><a href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/25/use-powershell-to-interact-with-the-windows-api-part-1/" target="_blank" rel="noopener">Part1</a><br><a href="https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Add-Type-39741f8c" target="_blank" rel="noopener">Copy-RawItem(Add-Type Version)</a><br><a href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/26/use-powershell-to-interact-with-the-windows-api-part-2/" target="_blank" rel="noopener">Part2</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.win32exception?view=netframework-4.8" target="_blank" rel="noopener">Win32Exception</a><br><a href="https://baike.baidu.com/item/计算机调查取证/9157286?fr=aladdin" target="_blank" rel="noopener">计算机取证</a><br><a href="http://gallery.technet.microsoft.com/scriptcenter/Find-WinAPIFunction-4166b223" target="_blank" rel="noopener">Find-WinAPIFunction</a><br><a href="https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Private-NET-78917643" target="_blank" rel="noopener">Copy-RawItem(Private .NET Method Version)</a><br><a href="https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/27/use-powershell-to-interact-with-the-windows-api-part-3/" target="_blank" rel="noopener">Part3</a><br><a href="https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Reflection-38fae6d4" target="_blank" rel="noopener">Copy-RawItem(Reflection Version)</a><br><a href="https://msdn.microsoft.com/en-us/library/bs22fky4(v=vs.110).aspx" target="_blank" rel="noopener">AppDomain.DefineDynamicAssembly</a><br><a href="https://msdn.microsoft.com/en-us/library/system.reflection.assembly(v=vs.110).aspx#Methods" target="_blank" rel="noopener">Assembly Class</a></p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">超速蜗牛</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://chaoyuew.gitee.io/WPS-29-Advanced-Windows-API-Interaction.html">https://chaoyuew.gitee.io/WPS-29-Advanced-Windows-API-Interaction.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://chaoyuew.gitee.io">超速蜗牛的博客</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/WPS-30-Advanced-Manage-Excel-File-Without-Excel-Installed.html"><i class="fas fa-angle-left">&nbsp;</i><span>Windows PowerShell进阶(30) 未安装Excel情况下操作Excel文件</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/WPS-28-Advanced-Excel-ComObject.html"><span>Windows PowerShell进阶(28) Excel ComObject</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2019 By 超速蜗牛</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>